import { normalize, isAbsolute, relative, dirname } from 'path';
import { parse, print } from 'graphql';
import { mergeTypeDefs } from '@graphql-toolkit/schema-merging';
import minimatch from 'minimatch';
import { OPERATION_KINDS, loadTypedefs, loadDocuments, loadSchema } from '@graphql-toolkit/core';
import cosmiconfig from 'cosmiconfig';
import { GraphQLFileLoader } from '@graphql-toolkit/graphql-file-loader';
import { UrlLoader } from '@graphql-toolkit/url-loader';
import { JsonFileLoader } from '@graphql-toolkit/json-file-loader';
export { Source } from '@graphql-toolkit/common';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function ExtendableBuiltin(cls) {
    function ExtendableBuiltin() {
        cls.apply(this, arguments);
    }
    ExtendableBuiltin.prototype = Object.create(cls.prototype);
    Object.setPrototypeOf(ExtendableBuiltin, cls);
    return ExtendableBuiltin;
}
function composeMessage() {
    var lines = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        lines[_i] = arguments[_i];
    }
    return lines.join('\n');
}
var ConfigNotFoundError = /** @class */ (function (_super) {
    __extends(ConfigNotFoundError, _super);
    function ConfigNotFoundError(message) {
        var _this = _super.call(this, message) || this;
        _this.name = _this.constructor.name;
        _this.message = message;
        return _this;
    }
    return ConfigNotFoundError;
}(ExtendableBuiltin(Error)));
var ConfigEmptyError = /** @class */ (function (_super) {
    __extends(ConfigEmptyError, _super);
    function ConfigEmptyError(message) {
        var _this = _super.call(this, message) || this;
        _this.name = _this.constructor.name;
        _this.message = message;
        return _this;
    }
    return ConfigEmptyError;
}(ExtendableBuiltin(Error)));
var ConfigInvalidError = /** @class */ (function (_super) {
    __extends(ConfigInvalidError, _super);
    function ConfigInvalidError(message) {
        var _this = _super.call(this, message) || this;
        _this.name = _this.constructor.name;
        _this.message = message;
        return _this;
    }
    return ConfigInvalidError;
}(ExtendableBuiltin(Error)));
var ProjectNotFoundError = /** @class */ (function (_super) {
    __extends(ProjectNotFoundError, _super);
    function ProjectNotFoundError(message) {
        var _this = _super.call(this, message) || this;
        _this.name = _this.constructor.name;
        _this.message = message;
        return _this;
    }
    return ProjectNotFoundError;
}(ExtendableBuiltin(Error)));
var LoadersMissingError = /** @class */ (function (_super) {
    __extends(LoadersMissingError, _super);
    function LoadersMissingError(message) {
        var _this = _super.call(this, message) || this;
        _this.name = _this.constructor.name;
        _this.message = message;
        return _this;
    }
    return LoadersMissingError;
}(ExtendableBuiltin(Error)));
var LoaderNoResultError = /** @class */ (function (_super) {
    __extends(LoaderNoResultError, _super);
    function LoaderNoResultError(message) {
        var _this = _super.call(this, message) || this;
        _this.name = _this.constructor.name;
        _this.message = message;
        return _this;
    }
    return LoaderNoResultError;
}(ExtendableBuiltin(Error)));
var ExtensionMissingError = /** @class */ (function (_super) {
    __extends(ExtensionMissingError, _super);
    function ExtensionMissingError(message) {
        var _this = _super.call(this, message) || this;
        _this.name = _this.constructor.name;
        _this.message = message;
        return _this;
    }
    return ExtensionMissingError;
}(ExtendableBuiltin(Error)));

var GraphQLProjectConfig = /** @class */ (function () {
    function GraphQLProjectConfig(_a) {
        var filepath = _a.filepath, name = _a.name, config = _a.config, extensionsRegistry = _a.extensionsRegistry;
        this.filepath = filepath;
        this.dirpath = dirname(filepath);
        this.name = name;
        this.extensions = config.extensions || {};
        this.schema = config.schema;
        this.documents = config.documents;
        this.include = config.include;
        this.exclude = config.exclude;
        this._extensionsRegistry = extensionsRegistry;
    }
    GraphQLProjectConfig.prototype.hasExtension = function (name) {
        return !!this.extensions[name];
    };
    GraphQLProjectConfig.prototype.extension = function (name) {
        var extension = this._extensionsRegistry.get(name);
        if (!extension) {
            throw new ExtensionMissingError("Project " + this.name + " is missing " + name + " extension");
        }
        return __assign(__assign({}, this.extensions[name]), { schema: this.schema, documents: this.documents, include: this.include, exclude: this.exclude });
    };
    GraphQLProjectConfig.prototype.getSchema = function (out) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.loadSchema(this.schema, out)];
            });
        });
    };
    GraphQLProjectConfig.prototype.getDocuments = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (!this.documents) {
                    return [2 /*return*/, []];
                }
                return [2 /*return*/, this.loadDocuments(this.documents)];
            });
        });
    };
    GraphQLProjectConfig.prototype.loadSchema = function (pointer, out) {
        return __awaiter(this, void 0, void 0, function () {
            var sources, mergedTypedefs;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        out = out || 'GraphQLSchema';
                        if (!(out === 'GraphQLSchema')) return [3 /*break*/, 1];
                        return [2 /*return*/, this._extensionsRegistry.loaders.schema.loadSchema(pointer)];
                    case 1: return [4 /*yield*/, this._extensionsRegistry.loaders.schema.loadTypeDefs(pointer, {
                            filterKinds: OPERATION_KINDS,
                        })];
                    case 2:
                        sources = _a.sent();
                        mergedTypedefs = mergeTypeDefs(sources.map(function (s) { return s.document; }));
                        if (typeof mergedTypedefs === 'string') {
                            if (out === 'string') {
                                return [2 /*return*/, mergedTypedefs];
                            }
                            else if (out === 'DocumentNode') {
                                return [2 /*return*/, parse(mergedTypedefs)];
                            }
                        }
                        else if ('kind' in mergedTypedefs) {
                            if (out === 'DocumentNode') {
                                return [2 /*return*/, mergedTypedefs];
                            }
                            else if (out === 'string') {
                                return [2 /*return*/, print(mergedTypedefs)];
                            }
                        }
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    GraphQLProjectConfig.prototype.loadDocuments = function (pointer) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (!pointer) {
                    return [2 /*return*/, []];
                }
                return [2 /*return*/, this._extensionsRegistry.loaders.documents.loadDocuments(pointer)];
            });
        });
    };
    GraphQLProjectConfig.prototype.match = function (filepath) {
        var _this = this;
        var isSchemaOrDocument = [this.schema, this.documents].some(function (pointer) {
            return match(filepath, _this.dirpath, pointer);
        });
        if (isSchemaOrDocument) {
            return true;
        }
        var isExcluded = this.exclude
            ? match(filepath, this.dirpath, this.exclude)
            : false;
        if (isExcluded) {
            return false;
        }
        var isIncluded = this.include
            ? match(filepath, this.dirpath, this.include)
            : false;
        if (isIncluded) {
            return true;
        }
        return false;
    };
    return GraphQLProjectConfig;
}());
// XXX: it works but uses nodejs - expose normalization of file and dir paths in config
function match(filepath, dirpath, pointer) {
    if (!pointer) {
        return false;
    }
    if (Array.isArray(pointer)) {
        return pointer.some(function (p) { return match(filepath, dirpath, p); });
    }
    if (typeof pointer === 'string') {
        var normalizedFilepath = normalize(isAbsolute(filepath) ? relative(dirpath, filepath) : filepath);
        return minimatch(normalizedFilepath, normalize(pointer), { dot: true });
    }
    if (typeof pointer === 'object') {
        return match(filepath, dirpath, Object.keys(pointer)[0]);
    }
    return false;
}

var cwd = typeof process !== 'undefined' ? process.cwd() : undefined;
function isMultipleProjectConfig(config) {
    return typeof config.projects === 'object';
}
function isSingleProjectConfig(config) {
    return typeof config.schema !== 'undefined';
}
function getConfig(filepath) {
    return __awaiter(this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!filepath) {
                        throw new Error("Defining a file path is required");
                    }
                    return [4 /*yield*/, createCosmiConfig().load(filepath)];
                case 1:
                    result = _a.sent();
                    if (!result) {
                        throw new ConfigNotFoundError(composeMessage("GraphQL Config file is not available: " + filepath, "Please check the config filepath."));
                    }
                    if (result.isEmpty) {
                        throw new ConfigEmptyError(composeMessage("GraphQL Config file is empty.", "Please check " + result.filepath));
                    }
                    return [2 /*return*/, {
                            config: result.config,
                            filepath: result.filepath,
                        }];
            }
        });
    });
}
function findConfig(rootDir) {
    if (rootDir === void 0) { rootDir = cwd; }
    return __awaiter(this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!rootDir) {
                        throw new Error("Defining a root directiry is required");
                    }
                    return [4 /*yield*/, createCosmiConfig().search(rootDir)];
                case 1:
                    result = _a.sent();
                    if (!result) {
                        throw new ConfigNotFoundError(composeMessage("GraphQL Config file is not available in the provided config directory: " + rootDir, "Please check the config directory."));
                    }
                    if (result.isEmpty) {
                        throw new ConfigEmptyError(composeMessage("GraphQL Config file is empty.", "Please check " + result.filepath));
                    }
                    return [2 /*return*/, {
                            config: result.config,
                            filepath: result.filepath,
                        }];
            }
        });
    });
}
function replaceEnv(content) {
    // https://regex101.com/r/k9saS6/1
    // Yes:
    //  ${NAME:DEFAULT}
    //  ${NAME:"DEFAULT"}
    //  ${NAME}
    // Not:
    //  ${NAME:}
    var R = /\$\{(?<name>[A-Z0-9_]+)(\:((?<value>[^\:]+)|(\"(?<customValue>[^\"]+)\")))?\}/gi;
    return content.replace(R, function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var _a = args[9], name = _a.name, value = _a.value, customValue = _a.customValue;
        return process.env[name] ? String(process.env[name]) : value || customValue;
    });
}
function transformContent(content) {
    return replaceEnv(content);
}
var cosmi = cosmiconfig;
var createCustomLoader = function (loader) {
    return {
        sync: function (filepath, content) {
            return loader(filepath, transformContent(content));
        },
        async: function (filepath, content) {
            return loader(filepath, transformContent(content));
        },
    };
};
var loadYaml = createCustomLoader(cosmi.loadYaml);
var loadJson = createCustomLoader(cosmi.loadJson);
function createCosmiConfig() {
    // We need to wrap loaders in order to access and transform file content (as string)
    // Cosmiconfig has transform option but at this point config is not a string but an object
    return cosmiconfig('graphql', {
        loaders: {
            '.js': { sync: cosmi.loadJs, async: cosmi.loadJs },
            '.json': loadJson,
            '.yaml': loadYaml,
            '.yml': loadYaml,
            noExt: loadYaml,
        },
    });
}

var LoadersRegistry = /** @class */ (function () {
    function LoadersRegistry(_a) {
        var cwd = _a.cwd;
        this._loaders = [];
        this.cwd = cwd;
    }
    LoadersRegistry.prototype.register = function (loader) {
        if (!this._loaders.some(function (l) { return l.loaderId() === loader.loaderId(); })) {
            this._loaders.push(loader);
        }
    };
    LoadersRegistry.prototype.loadTypeDefs = function (pointer, options) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, loadTypedefs(pointer, __assign({ loaders: this._loaders, cwd: this.cwd }, options))];
            });
        });
    };
    LoadersRegistry.prototype.loadDocuments = function (pointer, options) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, loadDocuments(pointer, __assign({ loaders: this._loaders, cwd: this.cwd }, options))];
            });
        });
    };
    LoadersRegistry.prototype.loadSchema = function (pointer, options) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, loadSchema(pointer, __assign({ loaders: this._loaders, cwd: this.cwd }, options))];
            });
        });
    };
    return LoadersRegistry;
}());

var GraphQLExtensionsRegistry = /** @class */ (function () {
    function GraphQLExtensionsRegistry(_a) {
        var cwd = _a.cwd;
        this._extensions = {};
        this.loaders = {
            schema: new LoadersRegistry({ cwd: cwd }),
            documents: new LoadersRegistry({ cwd: cwd }),
        };
        // schema
        this.loaders.schema.register(new GraphQLFileLoader());
        this.loaders.schema.register(new UrlLoader());
        this.loaders.schema.register(new JsonFileLoader());
        // documents
        this.loaders.documents.register(new GraphQLFileLoader());
    }
    GraphQLExtensionsRegistry.prototype.register = function (extensionFn) {
        var extension = extensionFn({
            logger: {},
            loaders: this.loaders,
        });
        this._extensions[extension.name] = extension;
    };
    GraphQLExtensionsRegistry.prototype.has = function (extensionName) {
        return !!this._extensions[extensionName];
    };
    GraphQLExtensionsRegistry.prototype.get = function (extensionName) {
        return this._extensions[extensionName];
    };
    GraphQLExtensionsRegistry.prototype.names = function () {
        return Object.keys(this._extensions);
    };
    GraphQLExtensionsRegistry.prototype.forEach = function (cb) {
        for (var extensionName in this._extensions) {
            cb(this._extensions[extensionName]);
        }
    };
    return GraphQLExtensionsRegistry;
}());

var cwd$1 = typeof process !== 'undefined' ? process.cwd() : undefined;
function loadConfig(_a) {
    var filepath = _a.filepath, _b = _a.rootDir, rootDir = _b === void 0 ? cwd$1 : _b, _c = _a.extensions, extensions = _c === void 0 ? [] : _c, _d = _a.throwOnMissing, throwOnMissing = _d === void 0 ? true : _d, _e = _a.throwOnEmpty, throwOnEmpty = _e === void 0 ? true : _e;
    return __awaiter(this, void 0, void 0, function () {
        var found, _f, error_1;
        return __generator(this, function (_g) {
            switch (_g.label) {
                case 0:
                    _g.trys.push([0, 5, , 6]);
                    if (!filepath) return [3 /*break*/, 2];
                    return [4 /*yield*/, getConfig(filepath)];
                case 1:
                    _f = _g.sent();
                    return [3 /*break*/, 4];
                case 2: return [4 /*yield*/, findConfig(rootDir)];
                case 3:
                    _f = _g.sent();
                    _g.label = 4;
                case 4:
                    found = _f;
                    return [2 /*return*/, new GraphQLConfig(found, extensions)];
                case 5:
                    error_1 = _g.sent();
                    if ((!throwOnMissing && error_1 instanceof ConfigNotFoundError) ||
                        (!throwOnEmpty && error_1 instanceof ConfigEmptyError)) {
                        return [2 /*return*/];
                    }
                    throw error_1;
                case 6: return [2 /*return*/];
            }
        });
    });
}
var GraphQLConfig = /** @class */ (function () {
    function GraphQLConfig(raw, extensions) {
        var _this = this;
        this._rawConfig = raw.config;
        this.filepath = raw.filepath;
        this.dirpath = dirname(raw.filepath);
        this.extensions = new GraphQLExtensionsRegistry({ cwd: this.dirpath });
        extensions.forEach(function (extension) {
            _this.extensions.register(extension);
        });
        this.projects = {};
        if (isMultipleProjectConfig(this._rawConfig)) {
            for (var projectName in this._rawConfig.projects) {
                var config = this._rawConfig.projects[projectName];
                this.projects[projectName] = new GraphQLProjectConfig({
                    filepath: this.filepath,
                    name: projectName,
                    config: config,
                    extensionsRegistry: this.extensions,
                });
            }
        }
        else if (isSingleProjectConfig(this._rawConfig)) {
            this.projects['default'] = new GraphQLProjectConfig({
                filepath: this.filepath,
                name: 'default',
                config: this._rawConfig,
                extensionsRegistry: this.extensions,
            });
        }
    }
    GraphQLConfig.prototype.getProject = function (name) {
        if (!name) {
            return this.getDefault();
        }
        var project = this.projects[name];
        if (!project) {
            throw new ProjectNotFoundError("Project '" + name + "' not found");
        }
        return project;
    };
    GraphQLConfig.prototype.getProjectForFile = function (filepath) {
        // Looks for a project that includes the file or the file is a part of schema or documents
        for (var projectName in this.projects) {
            if (this.projects.hasOwnProperty(projectName)) {
                var project = this.projects[projectName];
                if (project.match(filepath)) {
                    return project;
                }
            }
        }
        // The file doesn't match any of the project
        // Looks for a first project that has no `include` and `exclude`
        for (var projectName in this.projects) {
            if (this.projects.hasOwnProperty(projectName)) {
                var project = this.projects[projectName];
                if (!project.include && !project.exclude) {
                    return project;
                }
            }
        }
        throw new ProjectNotFoundError("File '" + filepath + "' doesn't match any project");
    };
    GraphQLConfig.prototype.getDefault = function () {
        return this.getProject('default');
    };
    return GraphQLConfig;
}());

// Kamil: somehow our build process doesn't emit `types.d.ts` file, this should force it...
function ɵ() { }

export { ConfigEmptyError, ConfigInvalidError, ConfigNotFoundError, ExtensionMissingError, GraphQLConfig, GraphQLProjectConfig, LoaderNoResultError, LoadersMissingError, ProjectNotFoundError, composeMessage, loadConfig, ɵ };
