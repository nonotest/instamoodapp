'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const pluginHelpers = require('@graphql-codegen/plugin-helpers');
const graphql = require('graphql');
const common = require('@graphql-toolkit/common');
const schemaMerging = require('@graphql-toolkit/schema-merging');

async function executePlugin(options, plugin) {
    if (!plugin || !plugin.plugin || typeof plugin.plugin !== 'function') {
        throw new pluginHelpers.DetailedError(`Invalid Custom Plugin "${options.name}"`, `
        Plugin ${options.name} does not export a valid JS object with "plugin" function.
  
        Make sure your custom plugin is written in the following form:
  
        module.exports = {
          plugin: (schema, documents, config) => {
            return 'my-custom-plugin-content';
          },
        };
        `);
    }
    const outputSchema = options.schemaAst || graphql.buildASTSchema(options.schema, options.config);
    const documents = options.documents || [];
    if (plugin.validate && typeof plugin.validate === 'function') {
        try {
            await plugin.validate(outputSchema, documents, options.config, options.outputFilename, options.allPlugins);
        }
        catch (e) {
            throw new pluginHelpers.DetailedError(`Plugin "${options.name}" validation failed:`, `
            ${e.message}
          `);
        }
    }
    return await Promise.resolve(plugin.plugin(outputSchema, documents, typeof options.config === 'object' ? { ...options.config } : options.config, {
        outputFile: options.outputFilename,
        allPlugins: options.allPlugins,
    }));
}

async function codegen(options) {
    const documents = options.documents || [];
    if (documents.length > 0 && !options.skipDocumentsValidation) {
        validateDuplicateDocuments(documents);
    }
    const pluginPackages = Object.keys(options.pluginMap).map(key => options.pluginMap[key]);
    if (!options.schemaAst) {
        options.schemaAst = schemaMerging.mergeSchemas({
            schemas: [],
            typeDefs: [options.schema],
            convertExtensions: true,
            assumeValid: true,
            assumeValidSDL: true,
            ...options.config,
        });
    }
    // merged schema with parts added by plugins
    let schemaChanged = false;
    let schemaAst = pluginPackages.reduce((schemaAst, plugin) => {
        const addToSchema = typeof plugin.addToSchema === 'function' ? plugin.addToSchema(options.config) : plugin.addToSchema;
        if (!addToSchema) {
            return schemaAst;
        }
        return schemaMerging.mergeSchemas({
            schemas: [schemaAst],
            typeDefs: [addToSchema],
        });
    }, options.schemaAst);
    const federationInConfig = pickFlag('federation', options.config);
    const isFederation = prioritize(federationInConfig, false);
    if (isFederation && !schemaAst.getDirective('external') && !schemaAst.getDirective('requires') && !schemaAst.getDirective('provides') && !schemaAst.getDirective('key')) {
        schemaChanged = true;
        schemaAst = schemaMerging.mergeSchemas({
            schemas: [schemaAst],
            typeDefs: [pluginHelpers.federationSpec],
            convertExtensions: true,
            assumeValid: true,
            assumeValidSDL: true,
        });
    }
    if (schemaChanged) {
        options.schema = graphql.parse(common.printSchemaWithDirectives(schemaAst));
    }
    const skipDocumentValidation = typeof options.config === 'object' && !Array.isArray(options.config) && options.config.skipDocumentsValidation;
    if (options.schemaAst && documents.length > 0 && !skipDocumentValidation) {
        const extraFragments = options.config && options.config['externalFragments'] ? options.config['externalFragments'] : [];
        const errors = await common.validateGraphQlDocuments(options.schemaAst, [...documents, ...extraFragments.map(f => ({ location: f.importFrom, document: { kind: graphql.Kind.DOCUMENT, definitions: [f.node] } }))]);
        common.checkValidationErrors(errors);
    }
    const prepend = new Set();
    const append = new Set();
    const output = await Promise.all(options.plugins.map(async (plugin) => {
        const name = Object.keys(plugin)[0];
        const pluginPackage = options.pluginMap[name];
        const pluginConfig = plugin[name] || {};
        const execConfig = typeof pluginConfig !== 'object'
            ? pluginConfig
            : {
                ...options.config,
                ...pluginConfig,
            };
        const result = await executePlugin({
            name,
            config: execConfig,
            parentConfig: options.config,
            schema: options.schema,
            schemaAst,
            documents: options.documents,
            outputFilename: options.filename,
            allPlugins: options.plugins,
            skipDocumentsValidation: options.skipDocumentsValidation,
        }, pluginPackage);
        if (typeof result === 'string') {
            return result || '';
        }
        else if (pluginHelpers.isComplexPluginOutput(result)) {
            if (result.append && result.append.length > 0) {
                for (const item of result.append) {
                    append.add(item);
                }
            }
            if (result.prepend && result.prepend.length > 0) {
                for (const item of result.prepend) {
                    prepend.add(item);
                }
            }
            return result.content || '';
        }
        return '';
    }));
    return [...sortPrependValues(Array.from(prepend.values())), ...output, ...append.values()].join('\n');
}
function resolveCompareValue(a) {
    if (a.startsWith('/*') || a.startsWith('//') || a.startsWith(' *') || a.startsWith(' */') || a.startsWith('*/')) {
        return 0;
    }
    else if (a.startsWith('package')) {
        return 1;
    }
    else if (a.startsWith('import')) {
        return 2;
    }
    else {
        return 3;
    }
}
function sortPrependValues(values) {
    return values.sort((a, b) => {
        const aV = resolveCompareValue(a);
        const bV = resolveCompareValue(b);
        if (aV < bV) {
            return -1;
        }
        if (aV > bV) {
            return 1;
        }
        return 0;
    });
}
function validateDuplicateDocuments(files) {
    // duplicated names
    const operationMap = {};
    files.forEach(file => {
        graphql.visit(file.document, {
            OperationDefinition(node) {
                if (typeof node.name !== 'undefined') {
                    if (!operationMap[node.name.value]) {
                        operationMap[node.name.value] = {
                            paths: new Set(),
                            contents: new Set(),
                        };
                    }
                    operationMap[node.name.value].paths.add(file.location);
                    operationMap[node.name.value].contents.add(graphql.print(node));
                }
            },
        });
    });
    const names = Object.keys(operationMap);
    if (names.length) {
        const duplicated = names.filter(name => operationMap[name].contents.size > 1);
        if (!duplicated.length) {
            return;
        }
        const list = duplicated
            .map(name => `
      * ${name} found in:
        ${[...operationMap[name].paths]
            .map(filepath => {
            return `
            - ${filepath}
          `.trimRight();
        })
            .join('')}
  `.trimRight())
            .join('');
        throw new pluginHelpers.DetailedError(`Not all operations have an unique name: ${duplicated.join(', ')}`, `
        Not all operations have an unique name
        ${list}
      `);
    }
}
function isObjectMap(obj) {
    return obj && typeof obj === 'object' && !Array.isArray(obj);
}
function prioritize(...values) {
    const picked = values.find(val => typeof val === 'boolean');
    if (typeof picked !== 'boolean') {
        return values[values.length - 1];
    }
    return picked;
}
function pickFlag(flag, config) {
    return isObjectMap(config) ? config[flag] : undefined;
}

exports.codegen = codegen;
exports.executePlugin = executePlugin;
