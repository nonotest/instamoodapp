'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopNamespace(e) {
  if (e && e.__esModule) { return e; } else {
    var n = {};
    if (e) {
      Object.keys(e).forEach(function (k) {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      });
    }
    n['default'] = e;
    return n;
  }
}

const urlLoader = require('@graphql-toolkit/url-loader');
const prismaYml = require('prisma-yml');

class PrismaLoader extends urlLoader.UrlLoader {
    loaderId() {
        return 'prisma';
    }
    async canLoad(prismaConfigFilePath, options) {
        if (typeof prismaConfigFilePath === 'string' && prismaConfigFilePath.endsWith('prisma.yml') && options.fs && options.path && options.os) {
            const path = options.path || (await new Promise(function (resolve) { resolve(_interopNamespace(require('path'))); }));
            const joinedYmlPath = path.join(options.cwd || process.cwd(), prismaConfigFilePath);
            const fs = options.fs;
            if (await new Promise(resolve => fs.exists(joinedYmlPath, resolve))) {
                return true;
            }
        }
        return false;
    }
    async load(prismaConfigFilePath, options) {
        const { graceful, envVars = {}, os = await new Promise(function (resolve) { resolve(_interopNamespace(require('os'))); }), path = await new Promise(function (resolve) { resolve(_interopNamespace(require('path'))); }) } = options;
        const home = os.homedir();
        const env = new prismaYml.Environment(home);
        await env.load();
        const joinedYmlPath = path.join(process.cwd(), prismaConfigFilePath);
        const definition = new prismaYml.PrismaDefinitionClass(env, joinedYmlPath, envVars);
        await definition.load({}, undefined, graceful);
        const serviceName = definition.service;
        const stage = definition.stage;
        const clusterName = definition.cluster;
        if (!clusterName) {
            throw new Error(`No cluster set. Please set the "cluster" property in your prisma.yml`);
        }
        const cluster = await definition.getCluster();
        if (!cluster) {
            throw new Error(`Cluster ${clusterName} provided in prisma.yml could not be found in global ~/.prisma/config.yml.
      Please check in ~/.prisma/config.yml, if the cluster exists.
      You can use \`docker-compose up -d\` to start a new cluster.`);
        }
        const token = definition.getToken(serviceName, stage);
        const url = cluster.getApiEndpoint(serviceName, stage, definition.getWorkspace() || undefined);
        const headers = token
            ? {
                Authorization: `Bearer ${token}`,
            }
            : undefined;
        return super.load(url, { headers });
    }
}

exports.PrismaLoader = PrismaLoader;
