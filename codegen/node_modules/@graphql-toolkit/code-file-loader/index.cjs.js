'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopNamespace(e) {
  if (e && e.__esModule) { return e; } else {
    var n = {};
    if (e) {
      Object.keys(e).forEach(function (k) {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      });
    }
    n['default'] = e;
    return n;
  }
}

const graphql = require('graphql');
const common = require('@graphql-toolkit/common');
const graphqlTagPluck = require('@graphql-toolkit/graphql-tag-pluck');

function isSchemaText(obj) {
    return typeof obj === 'string';
}
function isWrappedSchemaJson(obj) {
    const json = obj;
    return json.data !== undefined && json.data.__schema !== undefined;
}
function isSchemaJson(obj) {
    const json = obj;
    return json !== undefined && json.__schema !== undefined;
}
function isSchemaAst(obj) {
    return obj.kind !== undefined;
}
function resolveExport(fileExport) {
    if (graphql.isSchema(fileExport)) {
        return fileExport;
    }
    else if (isSchemaText(fileExport)) {
        return graphql.parse(fileExport);
    }
    else if (isWrappedSchemaJson(fileExport)) {
        return graphql.buildClientSchema(fileExport.data);
    }
    else if (isSchemaJson(fileExport)) {
        return graphql.buildClientSchema(fileExport);
    }
    else if (isSchemaAst(fileExport)) {
        return fileExport;
    }
    return null;
}
async function tryToLoadFromExport(rawFilePath) {
    let filePath = rawFilePath;
    try {
        if (typeof require !== 'undefined' && require.cache) {
            filePath = require.resolve(filePath);
            if (require.cache[filePath]) {
                delete require.cache[filePath];
            }
        }
        const rawExports = await new Promise(function (resolve) { resolve(_interopNamespace(require(filePath))); });
        if (rawExports) {
            let rawExport = rawExports.default || rawExports.schema || rawExports.typeDefs || rawExports.data || rawExports;
            if (rawExport) {
                let exportValue = await rawExport;
                exportValue = await (exportValue.default || exportValue.schema || exportValue.typeDefs || exportValue.data || exportValue);
                try {
                    return resolveExport(exportValue);
                }
                catch (e) {
                    throw new Error('Exported schema must be of type GraphQLSchema, text, AST, or introspection JSON.');
                }
            }
            else {
                throw new Error(`Invalid export from export file ${filePath}: missing default export or 'schema' export!`);
            }
        }
        else {
            throw new Error(`Invalid export from export file ${filePath}: empty export!`);
        }
    }
    catch (e) {
        throw new Error(`Unable to load from file "${filePath}": ${e.message}`);
    }
}
const FILE_EXTENSIONS = ['.ts', '.tsx', '.js', '.jsx', '.vue'];
class CodeFileLoader {
    loaderId() {
        return 'code-file';
    }
    async canLoad(pointer, options) {
        if (common.isValidPath(pointer) && options.path && options.fs) {
            const { resolve, isAbsolute } = options.path;
            if (FILE_EXTENSIONS.find(extension => pointer.endsWith(extension))) {
                const normalizedFilePath = isAbsolute(pointer) ? pointer : resolve(options.cwd || process.cwd(), pointer);
                const { exists } = options.fs;
                if (await new Promise(resolve => exists(normalizedFilePath, resolve))) {
                    return true;
                }
            }
        }
        return false;
    }
    async load(pointer, options) {
        const { resolve, isAbsolute } = options.path;
        const normalizedFilePath = isAbsolute(pointer) ? pointer : resolve(options.cwd || process.cwd(), pointer);
        try {
            const { readFile } = options.fs;
            const content = await new Promise((resolve, reject) => readFile(normalizedFilePath, { encoding: 'utf-8' }, (err, data) => (err ? reject(err) : resolve(data))));
            const rawSDL = await graphqlTagPluck.gqlPluckFromCodeString(normalizedFilePath, content, options.pluckConfig);
            if (rawSDL) {
                return common.parseGraphQLSDL(pointer, rawSDL, options);
            }
        }
        catch (e) {
            common.debugLog(`Failed to load schema from code file "${normalizedFilePath}": ${e.message}`);
            throw e;
        }
        if (!options.noRequire) {
            if (options && options.require) {
                await Promise.all(common.asArray(options.require).map(m => new Promise(function (resolve) { resolve(_interopNamespace(require(m))); })));
            }
            let loaded = await tryToLoadFromExport(normalizedFilePath);
            if (graphql.isSchema(loaded)) {
                return {
                    location: pointer,
                    schema: loaded,
                };
            }
            else if (loaded && loaded.kind === graphql.Kind.DOCUMENT) {
                return {
                    location: pointer,
                    document: loaded,
                };
            }
        }
        return null;
    }
}

exports.CodeFileLoader = CodeFileLoader;
