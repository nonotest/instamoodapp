CREATE TABLE ts_media_sources (
    id    INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name   VARCHAR(40) NOT NULL CHECK (name <> ''),

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ NULL
);

CREATE TABLE ts_trends (
    id    INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name   VARCHAR(100) NOT NULL CHECK (name <> ''),
    hashtag   VARCHAR(100) NOT NULL CHECK (hashtag <> ''),
    score INTEGER NOT NULL,

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ NULL,

    UNIQUE(name),
    UNIQUE(hashtag)
);

CREATE TABLE ts_medias (
    id    INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    media_source_id INTEGER,
    trend_id INTEGER,
    external_id   VARCHAR(40) NOT NULL CHECK (external_id <> ''),
    uuid UUID NOT NULL DEFAULT gen_random_uuid(),
    metadata        JSONB   NOT NULL,
    score INTEGER NOT NULL,

	FOREIGN KEY (media_source_id) REFERENCES ts_media_sources (id),
	FOREIGN KEY (trend_id) REFERENCES ts_trends (id),

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ NULL,

    UNIQUE(external_id)
);

-- TODO:
-- Store every "like";
-- Store every "dislike";
-- Derive like_count and dislike_count;

CREATE TABLE ts_medias_sentiments (
	media_id INTEGER,
	like_count INTEGER DEFAULT 0, -- for now this is anonymous
	dislike_count INTEGER DEFAULT 0, -- for now this is anonymous

    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
	FOREIGN KEY (media_id) REFERENCES ts_medias (id)
);

-- TODO: convert to mat_view

CREATE VIEW ts_top_trends_vw AS SELECT * FROM ts_trends ORDER BY score DESC OFFSET 0 LIMIT 10;

CREATE VIEW ts_medias_by_top_trends_vw AS
	SELECT
		m.id,
		m.external_id,
		m.score,
		m.uuid,
		m.metadata,
		m.created_at,
		m.updated_at,
		tt.name as trend_name,
		ms.name as media_source_name
	FROM
		ts_medias m
	INNER JOIN
		ts_top_trends_vw tt ON m.trend_id = tt.id
	INNER JOIN
		ts_media_sources ms ON ms.id = m.media_source_id;


		
DROP FUNCTION IF EXISTS read_top_medias_by_top_trends( INT, INT );
CREATE OR REPLACE FUNCTION read_top_medias_by_top_trends("limit" INT, "offset" INT)
    -- This is a quick workaround that allows us to
    -- Retrieve the same number as medias for each trend and be able to paginate it
    -- We should add indexes in the future
    -- It is unlikely that we return previously loaded items when advancing in the pagination
	 RETURNS SETOF ts_medias_by_top_trends_vw
	 AS $$     	
	  SELECT
	  	"n"."id",
	  	"n"."external_id",
	  	"n"."score",
	  	"n"."uuid",
	  	"n"."metadata",
	  	"n"."created_at",
	  	"n"."updated_at",
	   	"n"."trend_name",
	   	"n"."media_source_name"
	  FROM (  
			SELECT
				ROW_NUMBER()
			OVER(
				PARTITION BY ts_medias_by_top_trends_vw.trend_name
				ORDER BY ts_medias_by_top_trends_vw.score DESC, ts_medias_by_top_trends_vw.created_at DESC
			) AS rank, *
			FROM ts_medias_by_top_trends_vw
	  ) n
	  ORDER BY rank ASC, created_at desc 
	  LIMIT "limit" offset  "offset"
	$$
LANGUAGE sql STABLE;
