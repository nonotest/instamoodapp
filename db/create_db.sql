CREATE TABLE ts_media_sources (
  id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, 
  name VARCHAR(40) NOT NULL CHECK (name <> ''), 
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(), 
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(), 
  deleted_at TIMESTAMPTZ NULL
);
CREATE TABLE ts_trends (
  id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, 
  name VARCHAR(100) NOT NULL CHECK (name <> ''), 
  hashtag VARCHAR(100) NOT NULL CHECK (hashtag <> ''), 
  score INTEGER NOT NULL, 
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(), 
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(), 
  deleted_at TIMESTAMPTZ NULL, 
  UNIQUE(name), 
  UNIQUE(hashtag)
);
CREATE TABLE ts_medias (
  id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, 
  media_source_id INTEGER, 
  trend_id INTEGER, 
  external_id VARCHAR(40) NOT NULL CHECK (external_id <> ''), 
  uuid UUID NOT NULL DEFAULT gen_random_uuid(), 
  metadata JSONB NOT NULL, 
  score INTEGER NOT NULL, 
  FOREIGN KEY (media_source_id) REFERENCES ts_media_sources (id), 
  FOREIGN KEY (trend_id) REFERENCES ts_trends (id), 
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(), 
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(), 
  deleted_at TIMESTAMPTZ NULL, 
  UNIQUE(external_id)
);
CREATE TABLE ts_medias_sentiments (
  id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, 
  media_id INTEGER, 
  unique_device_id VARCHAR(100), 
  sentiment_type_id INTEGER, 
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(), 
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(), 
  deleted_at TIMESTAMPTZ NULL, 
  FOREIGN KEY (media_id) REFERENCES ts_medias (id)
);


CREATE VIEW ts_medias_by_top_trends_vw AS
	SELECT
		m.id,
		m.external_id,
		m.score,
		m.uuid,
		m.metadata,
		m.created_at,
		m.updated_at,
		tt.name as trend_name,
		ms.name as media_source_name
	FROM
		ts_medias m
	INNER JOIN
		ts_top_trends_vw tt ON m.trend_id = tt.id
	INNER JOIN
		ts_media_sources ms ON ms.id = m.media_source_id;


CREATE VIEW ts_medias_sentiments_vw AS
  SELECT ts_medias_sentiments.media_id,
      COALESCE(count(
          CASE
              WHEN ts_medias_sentiments.sentiment_type_id = 1 THEN 1
              ELSE NULL::integer
          END), 0::bigint) AS like_count,
      COALESCE(count(
          CASE
              WHEN ts_medias_sentiments.sentiment_type_id = 2 THEN 1
              ELSE NULL::integer
          END), 0::bigint) AS dislike_count
    FROM ts_medias_sentiments
    GROUP BY ts_medias_sentiments.media_id;


-- TODO: convert to mat_view
CREATE VIEW ts_top_trends_vw AS 
SELECT 
  * 
FROM 
  ts_trends 
ORDER BY 
  score DESC OFFSET 0 
LIMIT 
  10;

-- bit dumb that we have to create a table for a return type for hasura
CREATE TABLE read_top_medias_by_top_trends_fn  (
   id integer,
  external_id  varchar(40),
  score integer,
  uuid uuid ,
  metadata jsonb,
  created_at timestamptz,
  updated_at timestamptz,
  trend_name varchar(100),
  media_source_name varchar(40),
  like_count integer,
  dislike_count integer,
  sentiment_type_id  integer

);


DROP 
  FUNCTION IF EXISTS read_top_medias_by_top_trends(INTEGER, INTEGER, VARCHAR);
CREATE 
OR REPLACE FUNCTION read_top_medias_by_top_trends("limit" INT, "offset" INT, "user_unique_device_id" VARCHAR(100)) -- This is a quick workaround that allows us to
-- Retrieve the same number as medias for each trend and be able to paginate it
-- We should add indexes in the future
-- It is unlikely that we return previously loaded items when advancing in the pagination
RETURNS SETOF read_top_medias_by_top_trends_fn AS $$
WITH cte_medias AS (
  SELECT 
    ROW_NUMBER() OVER(
      PARTITION BY ts_medias_by_top_trends_vw.trend_name 
      ORDER BY 
        ts_medias_by_top_trends_vw.score DESC, 
        ts_medias_by_top_trends_vw.created_at DESC
    ) AS rank, 
    id, 
    external_id, 
    score, 
    uuid, 
    metadata, 
    created_at, 
    updated_at, 
    trend_name, 
    media_source_name 
  FROM 
    ts_medias_by_top_trends_vw 
  ORDER BY 
    rank ASC, 
    created_at desc 
  LIMIT 
    "limit" offset "offset" -- paginate medias
) 
SELECT 
  "c"."id",
  "c"."external_id",
  "c"."score",
  "c"."uuid",
  "c"."metadata",
  "c"."created_at",
  "c"."updated_at",
  "c"."trend_name",
  "c"."media_source_name", 
  COALESCE("ms"."like_count", 0)::integer as "like_count", 
  COALESCE("ms"."dislike_count", 0)::integer as "dislike_count", 
  "d"."sentiment_type_id"
FROM 
  cte_medias c 
  LEFT JOIN ts_medias_sentiments_vw ms ON ms.media_id = c.id 
  LEFT JOIN (
    SELECT 
      ts.media_id, 
      sentiment_type_id 
    FROM 
      ts_medias_sentiments ts 
    WHERE 
      unique_device_id = "user_unique_device_id"
  ) d ON c.id = d.media_id $$ LANGUAGE sql STABLE;
