CREATE TABLE ts_media_sources (
    id    INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name   VARCHAR(40) NOT NULL CHECK (name <> ''),

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ NULL
);

CREATE TABLE ts_trends (
    id    INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name   VARCHAR(100) NOT NULL CHECK (name <> ''),
    hashtag   VARCHAR(100) NOT NULL CHECK (hashtag <> ''),
    score INTEGER NOT NULL,

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ NULL,

    UNIQUE(name),
    UNIQUE(hashtag)
);

CREATE TABLE ts_medias (
    id    INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    media_source_id INTEGER,
    trend_id INTEGER,
    external_id   VARCHAR(40) NOT NULL CHECK (external_id <> ''),
    uuid UUID NOT NULL DEFAULT gen_random_uuid(),
    metadata        JSONB   NOT NULL,
    score INTEGER NOT NULL,

	FOREIGN KEY (media_source_id) REFERENCES ts_media_sources (id),
	FOREIGN KEY (trend_id) REFERENCES ts_trends (id),

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ NULL,

    UNIQUE(external_id)
);

  
CREATE TABLE ts_medias_sentiments (
	id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, 
	media_id INTEGER,
	unique_device_id VARCHAR(100),
	sentiment_type_id INTEGER,

    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ NULL,
	FOREIGN KEY (media_id) REFERENCES ts_medias (id)
);

-- TODO: convert to mat_view

CREATE VIEW ts_top_trends_vw AS SELECT * FROM ts_trends ORDER BY score DESC OFFSET 0 LIMIT 10;

CREATE VIEW ts_medias_by_top_trends_vw AS
	SELECT
		m.id,
		m.external_id,
		m.score,
		m.uuid,
		m.metadata,
		m.created_at,
		m.updated_at,
		tt.name as trend_name,
		ms.name as media_source_name
	FROM
		ts_medias m
	INNER JOIN
		ts_top_trends_vw tt ON m.trend_id = tt.id
	INNER JOIN
		ts_media_sources ms ON ms.id = m.media_source_id;

CREATE VIEW ts_medias_sentiments_vw AS
	SELECT 
		media_id,
		COUNT( CASE WHEN sentiment_type_id = 1 THEN 1 END ) AS like_count,
		COUNT( CASE WHEN sentiment_type_id = 2 THEN 1 END ) AS dislike_count, 
		JSON_OBJECT(ARRAY_AGG(unique_device_id)::text[]) as devices
	FROM ts_medias_sentiments
	GROUP BY media_id;

		
DROP FUNCTION IF EXISTS read_top_medias_by_top_trends( INT, INT );
CREATE OR REPLACE FUNCTION read_top_medias_by_top_trends("limit" INT, "offset" INT)
    -- This is a quick workaround that allows us to
    -- Retrieve the same number as medias for each trend and be able to paginate it
    -- We should add indexes in the future
    -- It is unlikely that we return previously loaded items when advancing in the pagination
	 RETURNS SETOF ts_medias_by_top_trends_vw
	 AS $$     	
	  SELECT
	  	"n"."id",
	  	"n"."external_id",
	  	"n"."score",
	  	"n"."uuid",
	  	"n"."metadata",
	  	"n"."created_at",
	  	"n"."updated_at",
	   	"n"."trend_name",
	   	"n"."media_source_name"
	  FROM (  
			SELECT
				ROW_NUMBER()
			OVER(
				PARTITION BY ts_medias_by_top_trends_vw.trend_name
				ORDER BY ts_medias_by_top_trends_vw.score DESC, ts_medias_by_top_trends_vw.created_at DESC
			) AS rank, *
			FROM ts_medias_by_top_trends_vw
	  ) n
	  ORDER BY rank ASC, created_at desc 
	  LIMIT "limit" offset  "offset"
	$$
LANGUAGE sql STABLE;

-- initial work on query with devices
-- devices here wont scale, we need to send the device id to the db for now
-- and return has_liked, has_disliked in the feed

SELECT 
	"ranked"."id",
    "ranked"."external_id",
    "ranked"."score",
    "ranked"."uuid",
    "ranked"."metadata",
    "ranked"."created_at",
    "ranked"."updated_at",
    "ranked"."trend_name",
    "ranked"."media_source_name",
    COALESCE("ms"."like_count",0) as "like_count",
    COALESCE("ms"."dislike_count",0) as "dislike_count", 
    "ms"."devices"
 FROM (
	SELECT
	       *
	      FROM (  
	            SELECT
	                ROW_NUMBER()
	            OVER(
	                PARTITION BY ts_medias_by_top_trends_vw.trend_name
	                ORDER BY ts_medias_by_top_trends_vw.score DESC, ts_medias_by_top_trends_vw.created_at DESC
	            ) AS rank, *
	            FROM ts_medias_by_top_trends_vw
	      ) n
	      ORDER BY rank ASC, created_at desc 
	      LIMIT 20 offset  0
	
	) ranked
	LEFT JOIN ts_medias_sentiments_vw ms ON ms.media_id = ranked.id
